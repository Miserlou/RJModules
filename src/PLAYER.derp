#include "cf.hpp"
#include "dsp/digital.hpp"
#include "osdialog.h"
#define DR_WAV_IMPLEMENTATION
#include "dr_wav.h"
#include <vector>
#include "cmath"
#include <dirent.h>
#include <algorithm> //----added by Joakim Lindbom


using namespace std;


struct PLAYER : Module {
    enum ParamIds {
        PLAY_PARAM,
        POS_PARAM,
        LSTART_PARAM,
        LSPEED_PARAM,
        TSTART_PARAM,
        TSPEED_PARAM,
        SPD_PARAM,
        NEXT_PARAM,
        PREV_PARAM,
        OSC_PARAM,
        NUM_PARAMS
    };
    enum InputIds {
        GATE_INPUT,
        POS_INPUT,
        SPD_INPUT,
    PREV_INPUT,
    NEXT_INPUT,
        TRIG_INPUT,
        VO_INPUT,
        NUM_INPUTS
    };
    enum OutputIds {
        OUT_OUTPUT,
        OUT2_OUTPUT,
        NUM_OUTPUTS
    };
    enum LightIds {
        OSC_LIGHT,
        NUM_LIGHTS
    };

    unsigned int channels;
    unsigned int sampleRate;
    drwav_uint64 totalSampleCount;

    vector<vector<float>> playBuffer;
    bool loading = false;

    bool play = false;

    string lastPath = "";


    float samplePos = 0;
    float startPos = 0;
    vector<double> displayBuff;

    string fileDesc;
    bool fileLoaded = false;

    dsp::SchmittTrigger playTrigger;
    dsp::SchmittTrigger playGater;
    dsp::SchmittTrigger nextTrigger;
    dsp::SchmittTrigger prevTrigger;
    dsp::SchmittTrigger nextinTrigger;
    dsp::SchmittTrigger previnTrigger;
    dsp::SchmittTrigger oscTrigger;

    vector <string> fichier;

    int sampnumber = 0;
    int retard = 0;
    bool reload = false ;
    bool oscState = false ;


    PLAYER() {
		config(NUM_PARAMS, NUM_INPUTS, NUM_OUTPUTS, NUM_LIGHTS);
            playBuffer.resize(2);
            playBuffer[0].resize(0);
            playBuffer[1].resize(0); }

    void step() override;

    void loadSample(std::string path);

    // persistence

    json_t *dataToJson() override {
        json_t *rootJ = json_object();
        // lastPath
        json_object_set_new(rootJ, "lastPath", json_string(lastPath.c_str()));
json_object_set_new(rootJ, "oscstate", json_integer(oscState));
        return rootJ;
    }

    void dataFromJson(json_t *rootJ) override {
        // lastPath
        json_t *lastPathJ = json_object_get(rootJ, "lastPath");
        if (lastPathJ) {
            lastPath = json_string_value(lastPathJ);
            reload = true ;
            loadSample(lastPath);

        }
    json_t *oscstateJ = json_object_get(rootJ, "oscstate");
        if (oscstateJ)
            oscState = json_integer_value(oscstateJ);
            lights[OSC_LIGHT].value=oscState;

    }
};

void PLAYER::loadSample(std::string path) {

        loading = true;
        unsigned int c;
        unsigned int sr;
        drwav_uint64 sc;
        float* pSampleData;
        pSampleData = drwav_open_and_read_file_f32(path.c_str(), &c, &sr, &sc);

    if (pSampleData != NULL) {
        channels = c;
        sampleRate = sr;
        playBuffer[0].clear();
        playBuffer[1].clear();
        for (unsigned int i=0; i < sc; i = i + c) {
            playBuffer[0].push_back(pSampleData[i]);
            if (channels == 2)
                playBuffer[1].push_back((float)pSampleData[i+1]);

        }
        totalSampleCount = playBuffer[0].size();
        drwav_free(pSampleData);
loading = false;


        fileLoaded = true;
        vector<double>().swap(displayBuff);
        for (int i=0; i < floor(totalSampleCount); i = i + floor(totalSampleCount/130)) {
            displayBuff.push_back(playBuffer[0][i]);
        }
        fileDesc = stringFilename(path)+ "\n";
        fileDesc += std::to_string(sampleRate)+ " Hz" + "\n";
        fileDesc += std::to_string(channels)+ " channel(s)" + "\n";

        if (reload) {
            DIR* rep = NULL;
            struct dirent* dirp = NULL;
            std::string dir = path.empty() ? assetLocal("") : stringDirectory(path);

            rep = opendir(dir.c_str());
            int i = 0;
            fichier.clear();
            while ((dirp = readdir(rep)) != NULL) {
                std::string name = dirp->d_name;

                std::size_t found = name.find(".wav",name.length()-5);
                if (found==std::string::npos) found = name.find(".WAV",name.length()-5);

                if (found!=std::string::npos) {
                    fichier.push_back(name);
                    if ((dir + "/" + name)==path) {sampnumber = i;}
                    i=i+1;
                    }

                }

//----added by Joakim Lindbom
        sort(fichier.begin(), fichier.end());  // Linux needs this to get files in right order
            for (int o=0;o<int(fichier.size()-1); o++) {
                if ((dir + "/" + fichier[o])==path) {
                    sampnumber = o;
                }
            }
//---------------

            closedir(rep);
            reload = false;
        }
            lastPath = path;
    }
    else {

        fileLoaded = false;
    }
}


void PLAYER::step() {
    if (fileLoaded) {
        if (nextTrigger.process(params[NEXT_PARAM].value)+nextinTrigger.process(inputs[NEXT_INPUT].value))
            {
            std::string dir = lastPath.empty() ? assetLocal("") : stringDirectory(lastPath);
            if (sampnumber < int(fichier.size()-1)) sampnumber=sampnumber+1; else sampnumber =0;
            loadSample(dir + "/" + fichier[sampnumber]);
            }


        if (prevTrigger.process(params[PREV_PARAM].value)+previnTrigger.process(inputs[PREV_INPUT].value))
            {retard = 1000;
            std::string dir = lastPath.empty() ? assetLocal("") : stringDirectory(lastPath);
            if (sampnumber > 0) sampnumber=sampnumber-1; else sampnumber =int(fichier.size()-1);
            loadSample(dir + "/" + fichier[sampnumber]);
            }
    } else fileDesc = "right click to load \n .wav sample \n :)";

if (oscTrigger.process(params[OSC_PARAM].value))
            {oscState =!oscState;lights[OSC_LIGHT].value=oscState;}

    // Play
if (!oscState) {
    bool gated = inputs[GATE_INPUT].value > 0;

    if (inputs[POS_INPUT].active)
    startPos = clamp((params[LSTART_PARAM].value + inputs[POS_INPUT].value * params[TSTART_PARAM].value),0.0f,10.0f)*totalSampleCount/10;
    else {startPos = clamp((params[LSTART_PARAM].value),0.0f,10.0f)*totalSampleCount/10;
        inputs[POS_INPUT].value = 0 ;
    }

    if (!inputs[TRIG_INPUT].active) {
    if (playGater.process(inputs[GATE_INPUT].value)) {
        play = true;
        samplePos = startPos;
        }
    } else {
    if (playTrigger.process(inputs[TRIG_INPUT].value)) {
        play = true;
        samplePos = startPos;
        }
    }

    if ((!loading) && (play) && ((floor(samplePos) < totalSampleCount) && (floor(samplePos) >= 0))) {
        if (channels == 1) {
            outputs[OUT_OUTPUT].value = 5 * playBuffer[0][floor(samplePos)];
            outputs[OUT2_OUTPUT].value = 5 * playBuffer[0][floor(samplePos)];}
        else if (channels ==2) {
            outputs[OUT_OUTPUT].value = 5 * playBuffer[0][floor(samplePos)];
            outputs[OUT2_OUTPUT].value = 5 * playBuffer[1][floor(samplePos)];
                }
        if (inputs[SPD_INPUT].active)
        samplePos = samplePos+powf(2.0, inputs[VO_INPUT].value)+(params[LSPEED_PARAM].value +inputs[SPD_INPUT].value * params[TSPEED_PARAM].value) /3;
        else {
            samplePos = samplePos+powf(2.0, inputs[VO_INPUT].value)+(params[LSPEED_PARAM].value) /3;
            inputs[SPD_INPUT].value = 0 ;}
    }
    else
    {
        play = false;
        outputs[OUT_OUTPUT].value = 0;outputs[OUT2_OUTPUT].value = 0;
    }
       if (!inputs[TRIG_INPUT].active) {if (gated == false) {play = false; outputs[OUT_OUTPUT].value = 0;outputs[OUT2_OUTPUT].value = 0;}}
} else {

    if (((floor(samplePos) < totalSampleCount) && (floor(samplePos) >= 0))) {
        if (playTrigger.process(inputs[TRIG_INPUT].value)) samplePos = 0;

        if (channels == 1) {
            outputs[OUT_OUTPUT].value = 5 * playBuffer[0][floor(samplePos)];
            outputs[OUT2_OUTPUT].value = 5 * playBuffer[0][floor(samplePos)];}
        else if (channels ==2) {
            outputs[OUT_OUTPUT].value = 5 * playBuffer[0][floor(samplePos)];
            outputs[OUT2_OUTPUT].value = 5 * playBuffer[1][floor(samplePos)];
                }
        if (inputs[SPD_INPUT].active)
        samplePos = samplePos+powf(2.0, inputs[VO_INPUT].value)+(params[LSPEED_PARAM].value +inputs[SPD_INPUT].value * params[TSPEED_PARAM].value) /3;
        else {
            samplePos = samplePos+powf(2.0, inputs[VO_INPUT].value)+(params[LSPEED_PARAM].value) /3;
            inputs[SPD_INPUT].value = 0 ;}
    }
    else
    {
        samplePos=0;
    }

    }
}

struct upButton : SVGSwitch, MomentarySwitch {
    upButton() {
        addFrame(APP->window->loadSvg(asset::plugin(pluginInstance, "res/upButton.svg")));
        addFrame(APP->window->loadSvg(asset::plugin(pluginInstance, "res/upButtonDown.svg")));
        sw->wrap();
        box.size = sw->box.size;
    }
};
struct downButton : SVGSwitch, MomentarySwitch {
    downButton() {
        addFrame(APP->window->loadSvg(asset::plugin(pluginInstance, "res/downButton.svg")));
        addFrame(APP->window->loadSvg(asset::plugin(pluginInstance, "res/downButtonDown.svg")));
        sw->wrap();
        box.size = sw->box.size;
    }
};

struct PLAYERDisplay : TransparentWidget {
    PLAYER *module;
    int frame = 0;
    shared_ptr<Font> font;

    PLAYERDisplay() {
        font = Font::load(assetPlugin(pluginInstance, "res/DejaVuSansMono.ttf"));
    }

    void draw(NVGcontext *vg) override {
        nvgFontSize(vg, 12);
        nvgFontFaceId(vg, font->handle);
        nvgTextLetterSpacing(vg, -2);
        nvgFillColor(vg, nvgRGBA(0xff, 0xff, 0xff, 0xff));
        nvgTextBox(vg, 5, 5,120, module->fileDesc.c_str(), NULL);

        // Draw ref line
        nvgStrokeColor(vg, nvgRGBA(0xff, 0xff, 0xff, 0x40));
        {
            nvgBeginPath(vg);
            nvgMoveTo(vg, 0, 125);
            nvgLineTo(vg, 125, 125);
            nvgClosePath(vg);
        }
        nvgStroke(vg);

        if (module->fileLoaded) {
            // Draw play line
            nvgStrokeColor(vg, nvgRGBA(0x28, 0xb0, 0xf3, 0xff));
            nvgStrokeWidth(vg, 0.8);
            {
                nvgBeginPath(vg);
                nvgMoveTo(vg, floor(module->samplePos * 125 / module->totalSampleCount) , 85);
                nvgLineTo(vg, floor(module->samplePos * 125 / module->totalSampleCount) , 165);
                nvgClosePath(vg);
            }
            nvgStroke(vg);

            // Draw start line
            nvgStrokeColor(vg, nvgRGBA(0x28, 0xb0, 0xf3, 0xff));
            nvgStrokeWidth(vg, 1.5);
            {
                nvgBeginPath(vg);
                nvgMoveTo(vg, floor(module->startPos * 125 / module->totalSampleCount) , 85);
                nvgLineTo(vg, floor(module->startPos * 125 / module->totalSampleCount) , 165);
                nvgClosePath(vg);
            }
            nvgStroke(vg);


            // Draw waveform
            nvgStrokeColor(vg, nvgRGBA(0xe1, 0x02, 0x78, 0xc0));
            nvgSave(vg);
            Rect b = Rect(Vec(0, 85), Vec(125, 80));
            nvgScissor(vg, b.pos.x, b.pos.y, b.size.x, b.size.y);
            nvgBeginPath(vg);
            for (unsigned int i = 0; i < module->displayBuff.size(); i++) {
                float x, y;
                x = (float)i / (module->displayBuff.size() - 1);
                y = module->displayBuff[i] / 2.0 + 0.5;
                Vec p;
                p.x = b.pos.x + b.size.x * x;
                p.y = b.pos.y + b.size.y * (1.0 - y);
                if (i == 0)
                    nvgMoveTo(vg, p.x, p.y);
                else
                    nvgLineTo(vg, p.x, p.y);
            }
            nvgLineCap(vg, NVG_ROUND);
            nvgMiterLimit(vg, 2.0);
            nvgStrokeWidth(vg, 1.5);
            nvgGlobalCompositeOperation(vg, NVG_LIGHTER);
            nvgStroke(vg);
            nvgResetScissor(vg);
            nvgRestore(vg);
        }
    }
};



struct PLAYERWidget : ModuleWidget {
    PLAYERWidget(PLAYER *module);
    Menu *createContextMenu() override;
};

PLAYERWidget::PLAYERWidget(PLAYER *module) {
		setModule(module);
    setPanel(APP->window->loadSvg(asset::plugin(pluginInstance, "res/PLAYER.svg")));

    addChild(createWidget<ScrewSilver>(Vec(15, 0)));
    addChild(createWidget<ScrewSilver>(Vec(box.size.x-30, 0)));
    addChild(createWidget<ScrewSilver>(Vec(15, 365)));
    addChild(createWidget<ScrewSilver>(Vec(box.size.x-30, 365)));

    {
        PLAYERDisplay *display = new PLAYERDisplay();
        display->module = module;
        display->box.pos = Vec(5, 40);
        display->box.size = Vec(130, 250);
        addChild(display);
    }

    static const float portX0[4] = {10, 40, 70, 100};


    addParam(createParam<RoundLargeBlackKnob>(Vec(23, 235), module, PLAYER::LSTART_PARAM, 0.0f, 10.0f, 0.0f));
    addParam(createParam<RoundLargeBlackKnob>(Vec(73, 235), module, PLAYER::LSPEED_PARAM, -5.0f, 5.0f, 0.0f));
    addParam(createParam<Trimpot>(Vec(42, 278), module, PLAYER::TSTART_PARAM, -1.0f, 1.0f, 0.0f));
    addParam(createParam<Trimpot>(Vec(73, 278), module, PLAYER::TSPEED_PARAM, -1.0f, 1.0f, 0.0f));

    addInput(createInput<PJ301MPort>(Vec(portX0[0], 321), module, PLAYER::GATE_INPUT));
    addInput(createInput<PJ301MPort>(Vec(portX0[1], 321), module, PLAYER::POS_INPUT));
    addInput(createInput<PJ301MPort>(Vec(portX0[2], 321), module, PLAYER::SPD_INPUT));
    addOutput(createOutput<PJ301MPort>(Vec(portX0[3], 275), module, PLAYER::OUT_OUTPUT));
    addOutput(createOutput<PJ301MPort>(Vec(portX0[3], 321), module, PLAYER::OUT2_OUTPUT));

    addInput(createInput<PJ301MPort>(Vec(portX0[0], 91), module, PLAYER::PREV_INPUT));
    addInput(createInput<PJ301MPort>(Vec(portX0[3], 91), module, PLAYER::NEXT_INPUT));
    addInput(createInput<PJ301MPort>(Vec(portX0[0], 275), module, PLAYER::TRIG_INPUT));
    addParam(createParam<upButton>(Vec(43, 95), module, PLAYER::PREV_PARAM, 0.0f, 1.0f, 0.0f));
    addParam(createParam<downButton>(Vec(73, 95), module, PLAYER::NEXT_PARAM, 0.0f, 1.0f, 0.0f));

    addParam(createParam<LEDButton>(Vec(104, 212), module, PLAYER::OSC_PARAM, 0.0, 1.0, 0.0));
        addChild(createLight<MediumLight<BlueLight>>(Vec(108.4, 216.4), module, PLAYER::OSC_LIGHT));
    addInput(createInput<PJ301MPort>(Vec(portX0[0], 210), module, PLAYER::VO_INPUT));
}

struct PLAYERItem : MenuItem {
    PLAYER *player;
    void onAction(EventAction &e) override {

        std::string dir = player->lastPath.empty() ? assetLocal("") : stringDirectory(player->lastPath);
        char *path = osdialog_file(OSDIALOG_OPEN, dir.c_str(), NULL, NULL);
        if (path) {
            player->play = false;
            player->reload = true;
            player->loadSample(path);
            player->samplePos = 0;
            player->lastPath = path;
            free(path);
        }
    }
};

Menu *PLAYERcreateWidgetContextMenu() {
    Menu *menu = ModulecreateWidgetContextMenu();

    MenuLabel *spacerLabel = new MenuLabel();
    menu->addChild(spacerLabel);

    PLAYER *player = dynamic_cast<PLAYER*>(module);
    assert(player);

    PLAYERItem *sampleItem = new PLAYERItem();
    sampleItem->text = "Load sample";
    sampleItem->player = player;
    menu->addChild(sampleItem);

    return menu;
}

Model *modelPLAYER = createModel<PLAYER, PLAYERWidget>("cf", "PLAYER", "Player", SAMPLER_TAG);
